// SPDX-License-Identifier: Apache-2.0
// Copyright 2025 Petro Rovenskyi

/// Test vectors for V5 frame tests.
///
/// Generated using Python with correct V5 frame structure:
/// - Frame size = payload_length + 13
/// - Payload = frametype(1) + status(1) + times(12) + modbus
///
/// Verified against pysolarmanv5 reference implementation.
enum TestVectors {
    // MARK: - Valid Frames

    /// Valid response: 34 bytes, length_field=21
    /// Serial: 0x12345678, Sequence: 1
    /// Modbus: Read 1 register, value=0x1234
    /// Times: total=3600, power=1800, offset=0
    static let validResponse: [UInt8] = [
        0xA5, 0x15, 0x00, 0x10, 0x15, 0x01, 0x00, 0x78, 0x56, 0x34, 0x12,
        0x02, 0x01, 0x10, 0x0E, 0x00, 0x00, 0x08, 0x07, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x02, 0x12, 0x34, 0xB5, 0x33,
        0xB3, 0x15,
    ]

    /// Minimum valid frame: 32 bytes, length_field=19
    /// 5-byte modbus: unit + func + 1 data + 2 CRC
    static let minimumValid: [UInt8] = [
        0xA5, 0x13, 0x00, 0x10, 0x15, 0x01, 0x00, 0x78, 0x56, 0x34, 0x12,
        0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x00, 0x85, 0xC8,
        0xA1, 0x15,
    ]

    /// Simple frame for decoder tests: 29 bytes
    /// 2-byte modbus payload
    static let simpleFrame: [UInt8] = [
        0xA5, 0x10, 0x00, 0x10, 0x15, 0x01, 0x00, 0x78, 0x56, 0x34, 0x12,
        0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x42, 0x43,
        0xD2, 0x15,
    ]

    // MARK: - Edge Cases

    /// Max time values: 0xFFFFFFFF for all times
    static let maxTimes: [UInt8] = [
        0xA5, 0x15, 0x00, 0x10, 0x15, 0x01, 0x00, 0x78, 0x56, 0x34, 0x12,
        0x02, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x03, 0x02, 0x12, 0x34, 0xB5, 0x33,
        0x7A, 0x15,
    ]

    /// Max sequence: 0xFFFF
    static let maxSequence: [UInt8] = [
        0xA5, 0x15, 0x00, 0x10, 0x15, 0xFF, 0xFF, 0x78, 0x56, 0x34, 0x12,
        0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x02, 0x12, 0x34, 0xB5, 0x33,
        0x83, 0x15,
    ]

    /// Max serial: 0xFFFFFFFF
    static let maxSerial: [UInt8] = [
        0xA5, 0x15, 0x00, 0x10, 0x15, 0x01, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x02, 0x12, 0x34, 0xB5, 0x33,
        0x6E, 0x15,
    ]

    /// Zero sequence
    static let zeroSequence: [UInt8] = [
        0xA5, 0x15, 0x00, 0x10, 0x15, 0x00, 0x00, 0x78, 0x56, 0x34, 0x12,
        0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x02, 0x12, 0x34, 0xB5, 0x33,
        0x85, 0x15,
    ]

    /// Large modbus frame: 128 bytes total, 101-byte modbus
    static let largeModbus: [UInt8] = [
        0xA5, 0x73, 0x00, 0x10, 0x15, 0x01, 0x00, 0x78, 0x56, 0x34, 0x12,
        0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x60,
        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00,
        0xD4, 0x15,
    ]

    // MARK: - Real-World Serial Numbers

    /// Serial: 1712345678 (17xxxxxxx format)
    static let serial17: [UInt8] = [
        0xA5, 0x15, 0x00, 0x10, 0x15, 0x01, 0x00, 0x4E, 0x52, 0x10, 0x66,
        0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x02, 0x12, 0x34, 0xB5, 0x33,
        0x88, 0x15,
    ]

    /// Serial: 2112345678 (21xxxxxxx format)
    static let serial21: [UInt8] = [
        0xA5, 0x15, 0x00, 0x10, 0x15, 0x01, 0x00, 0x4E, 0xD6, 0xE7, 0x7D,
        0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x02, 0x12, 0x34, 0xB5, 0x33,
        0xFA, 0x15,
    ]

    // MARK: - Real-World Format Data

    /// Realistic Deye inverter response (serial: 3112345678)
    /// Based on real V5 frame structure captured from production inverter.
    /// Uses fake serial number for privacy.
    ///
    /// Frame breakdown:
    /// - Serial: 3112345678 (0xB982A04E LE: 4E A0 82 B9) - Deye 31xxxxxxx format
    /// - Sequence: 1
    /// - Times: totalWorkingTime=0x00124D42 (~1.2M seconds), powerOnTime=0x00124D42
    /// - Modbus: 01 03 02 00 02 39 85 (read response, 2 bytes, value=0x0002, CRC=0x8539)
    static let realisticDeyeResponse: [UInt8] = [
        0xA5, 0x15, 0x00, 0x10, 0x15, 0x01, 0x00, 0x4E, 0xA0, 0x82, 0xB9,
        0x02, 0x01, 0x42, 0x4D, 0x12, 0x00, 0x42, 0x4D, 0x12, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x03, 0x02, 0x00, 0x02, 0x39, 0x85, 0x6F,
        0x15,
    ]

    // MARK: - Invalid Control Codes (for error tests)

    /// Heartbeat control code (0x4710) - invalid for response
    static let heartbeatControl: [UInt8] = [
        0xA5, 0x15, 0x00, 0x10, 0x47, 0x01, 0x00, 0x78, 0x56, 0x34, 0x12,
        0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x02, 0x12, 0x34, 0xB5, 0x33,
        0xB8, 0x15,
    ]

    /// Request control code (0x4510) - invalid for response
    static let requestControl: [UInt8] = [
        0xA5, 0x15, 0x00, 0x10, 0x45, 0x01, 0x00, 0x78, 0x56, 0x34, 0x12,
        0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x02, 0x12, 0x34, 0xB5, 0x33,
        0xB6, 0x15,
    ]
}
